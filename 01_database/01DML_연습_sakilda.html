<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MySQL DML - SELECT 심화 강의안 (Sakila)</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header class="header">
    <div class="container">
      <h1 class="title">MySQL DML – SELECT 심화 강의안</h1>
      <p class="subtitle">Sakila 데이터셋 기반 · 초보자(중학생 이해 기준) · JOIN 심화 + 서브쿼리 포함</p>

      <nav class="toc">
        <a href="#goal">학습 목표</a>
        <a href="#sakila">Sakila 소개</a>
        <a href="#select-basic">SELECT 기본</a>
        <a href="#where">WHERE</a>
        <a href="#between-in">BETWEEN/IN</a>
        <a href="#like">LIKE</a>
        <a href="#null">NULL</a>
        <a href="#order-limit">ORDER BY/LIMIT</a>
        <a href="#distinct">DISTINCT</a>
        <a href="#aggregate">집계 함수</a>
        <a href="#groupby-having">GROUP BY/HAVING</a>
        <a href="#join">JOIN</a>
        <a href="#subquery">서브쿼리</a>
        <a href="#execution-order">SELECT 실행 순서</a>
        <a href="#summary">정리</a>
      </nav>
    </div>
  </header>

  <main class="container">

    <section id="goal" class="section">
      <h2>학습 목표</h2>
      <div class="card">
        <ul class="list">
          <li>SELECT 문법을 빠짐없이 이해하는 것이 목표이다.</li>
          <li>조건, 정렬, 통계, 테이블 연결까지 조회할 수 있도록 하는 것이 목표이다.</li>
          <li>실무형 문제(EXP 유형)를 혼자서 풀 수 있는 수준에 도달하는 것이 목표이다.</li>
          <li>서브쿼리를 이용해 “조건/값/테이블처럼” 조회할 수 있도록 하는 것이 목표이다.</li>
        </ul>
      </div>
    </section>

    <section id="sakila" class="section">
      <h2>Sakila 소개</h2>
      <div class="card">
        <p>Sakila는 MySQL에서 제공하는 영화 대여점 예제 데이터베이스이다. 실제 서비스와 비슷한 구조를 가지고 있어 SQL 연습에 적합하다.</p>
        <h3>주요 테이블</h3>
        <table class="table">
          <thead>
            <tr>
              <th>테이블</th>
              <th>설명</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>actor</td><td>배우 정보 테이블이다.</td></tr>
            <tr><td>film</td><td>영화 정보 테이블이다.</td></tr>
            <tr><td>film_actor</td><td>영화-배우 연결 테이블이다.</td></tr>
            <tr><td>category</td><td>장르 정보 테이블이다.</td></tr>
            <tr><td>film_category</td><td>영화-장르 연결 테이블이다.</td></tr>
            <tr><td>customer</td><td>고객 정보 테이블이다.</td></tr>
            <tr><td>rental</td><td>대여 기록 테이블이다.</td></tr>
            <tr><td>payment</td><td>결제 기록 테이블이다.</td></tr>
            <tr><td>inventory</td><td>매장 재고(영화 복사본) 정보 테이블이다.</td></tr>
            <tr><td>store</td><td>매장 정보 테이블이다.</td></tr>
            <tr><td>staff</td><td>직원 정보 테이블이다.</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <section id="select-basic" class="section">
      <h2>SELECT 기본</h2>
      <div class="card">
        <p>SELECT는 데이터베이스에서 정보를 찾아서 보여달라고 요청하는 명령어이다. FROM은 어디에서 가져올지를 의미한다.</p>

        <h3>기본 형태</h3>
        <pre><code>SELECT 컬럼
FROM 테이블;</code></pre>

        <h3>전체 조회</h3>
        <p><code>*</code>는 모든 열을 의미한다. 학습 단계에서는 사용 가능하지만 실무에서는 자주 사용하지 않는 편이 좋다.</p>
        <pre><code>SELECT *
FROM film;</code></pre>

        <h3>필요한 열만 조회</h3>
        <pre><code>SELECT title, rental_rate
FROM film;</code></pre>

        <h3>컬럼 별명(AS)</h3>
        <p>AS는 결과 화면에 보이는 열 이름을 보기 좋게 바꾸는 기능이다. 실제 데이터는 바뀌지 않는다.</p>
        <pre><code>SELECT
  title AS 영화제목,
  rental_rate AS 대여요금
FROM film;</code></pre>
      </div>
    </section>

    <section id="where" class="section">
      <h2>WHERE</h2>
      <div class="card">
        <p>WHERE는 조건에 맞는 행만 선택하는 필터 역할이다.</p>

        <h3>문자열 조건</h3>
        <p>문자열은 작은따옴표로 감싸는 것이 규칙이다.</p>
        <pre><code>SELECT title, rating
FROM film
WHERE rating = 'PG';</code></pre>

        <h3>숫자 조건</h3>
        <pre><code>SELECT title, rental_rate
FROM film
WHERE rental_rate &gt; 3;</code></pre>

        <h3>여러 조건(AND/OR)</h3>
        <p>AND는 모든 조건을 만족해야 포함되는 조건이다. OR는 하나만 만족해도 포함되는 조건이다.</p>
        <pre><code>SELECT title, rental_rate, rating
FROM film
WHERE rental_rate &gt;= 2
  AND rating = 'PG-13';</code></pre>

        <pre><code>SELECT title, rating
FROM film
WHERE rating = 'PG'
   OR rating = 'G';</code></pre>

        <h3>부정 조건(아닌 값)</h3>
        <p>특정 값이 <strong>아닌</strong> 데이터를 고를 때는 <code>&lt;&gt;</code> 또는 <code>!=</code>를 사용한다.</p>
        <pre><code>SELECT title, rating
FROM film
WHERE rating &lt;&gt; 'PG';</code></pre>

        <h3>컬럼끼리 비교하기(EXP 유형)</h3>
        <p>WHERE에서는 컬럼과 숫자만 비교하는 것이 아니라, <strong>컬럼과 컬럼도 비교</strong>할 수 있다.</p>
        <pre><code>-- 예: replacement_cost가 rental_rate보다 큰 영화만 보기
SELECT title, rental_rate, replacement_cost
FROM film
WHERE replacement_cost &gt; rental_rate;</code></pre>

        <h3>연산(계산) 조건(EXP 유형)</h3>
        <p>사칙연산(+ - * /)으로 계산한 결과에 조건을 걸 수 있다.</p>
        <pre><code>-- 예: replacement_cost - rental_rate 차이가 10 이상인 영화
SELECT title, rental_rate, replacement_cost
FROM film
WHERE (replacement_cost - rental_rate) &gt;= 10;</code></pre>

        <h3>날짜 조건(EXP 유형)</h3>
        <p>날짜도 문자열처럼 작은따옴표로 감싸서 비교한다. <code>&gt;=</code>, <code>&lt;=</code>, <code>BETWEEN</code>으로 범위를 쉽게 만들 수 있다.</p>
        <pre><code>-- 특정 날짜 이후 대여 기록
SELECT rental_id, rental_date
FROM rental
WHERE rental_date &gt;= '2005-07-01';</code></pre>

        <div class="note">
          <strong>추가 팁</strong>
          <p>WHERE 조건은 가능하면 PK(기본키) 기반으로 작성하는 것이 가장 안전하다.</p>
        </div>
      </div>
    </section>

    <section id="between-in" class="section">
      <h2>BETWEEN과 IN</h2>
      <div class="card">
        <h3>BETWEEN</h3>
        <p>BETWEEN은 범위를 의미한다. 시작값과 끝값을 모두 포함하는 조건이다.</p>
        <pre><code>SELECT title, rental_rate
FROM film
WHERE rental_rate BETWEEN 2 AND 4;</code></pre>

        <h3>IN</h3>
        <p>IN은 여러 값 중 하나라도 같으면 포함되는 조건이다. 여러 OR 조건을 간단히 표현한 것이다.</p>
        <pre><code>SELECT title, rating
FROM film
WHERE rating IN ('PG', 'G', 'PG-13');</code></pre>

        <h3>서브쿼리 + IN 미리보기</h3>
        <p>IN 안에 값을 직접 쓰지 않고, <strong>다른 SELECT 결과를 넣는 방식</strong>도 자주 사용한다.</p>
        <pre><code>-- 'Comedy' 장르에 속한 영화 제목 보기 (IN + 서브쿼리)
SELECT title
FROM film
WHERE film_id IN (
  SELECT fc.film_id
  FROM film_category fc
  WHERE fc.category_id = (
    SELECT category_id
    FROM category
    WHERE name = 'Comedy'
  )
);</code></pre>
      </div>
    </section>

    <section id="like" class="section">
      <h2>LIKE</h2>
      <div class="card">
        <p>LIKE는 문자열에 특정 글자가 포함되는지 확인하는 기능이다.</p>

        <h3>포함 검색</h3>
        <pre><code>SELECT title
FROM film
WHERE title LIKE '%LOVE%';</code></pre>

        <div class="note">
          <strong>%의 의미</strong>
          <ul class="list">
            <li><code>%LOVE%</code>는 LOVE가 어디에 있든 포함되면 되는 조건이다.</li>
            <li><code>LOVE%</code>는 LOVE로 시작하면 되는 조건이다.</li>
            <li><code>%LOVE</code>는 LOVE로 끝나면 되는 조건이다.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="null" class="section">
      <h2>NULL</h2>
      <div class="card">
        <p>NULL은 값이 없는 상태이다. 0이나 빈 문자열과 다른 개념이다. NULL은 <code>=</code>로 비교할 수 없고 <code>IS NULL</code>로만 비교하는 것이 규칙이다.</p>

        <h3>NULL 조회</h3>
        <pre><code>SELECT *
FROM customer
WHERE email IS NULL;</code></pre>

        <h3>NULL이 아닌 값 조회</h3>
        <pre><code>SELECT *
FROM customer
WHERE email IS NOT NULL;</code></pre>

        <h3>EXP 유형: OR와 NULL 결합</h3>
        <p>NULL은 비교 연산으로 걸러지지 않을 수 있으므로 OR로 같이 처리하는 것이 중요하다.</p>
        <pre><code>SELECT *
FROM payment
WHERE amount &lt; 1
   OR amount IS NULL;</code></pre>
      </div>
    </section>

    <section id="order-limit" class="section">
      <h2>ORDER BY와 LIMIT</h2>
      <div class="card">
        <h3>정렬(ORDER BY)</h3>
        <p>ORDER BY는 결과를 정렬하는 기능이다. DESC는 내림차순이고 ASC는 오름차순이다.</p>
        <pre><code>SELECT title, rental_rate
FROM film
ORDER BY rental_rate DESC;</code></pre>

        <h3>다중 정렬(EXP 유형)</h3>
        <p>첫 번째 기준이 같을 때 두 번째 기준으로 다시 정렬하는 방식이다.</p>
        <pre><code>SELECT title, rating, rental_rate
FROM film
ORDER BY rating ASC, rental_rate DESC;</code></pre>

        <h3>임의(랜덤)로 뽑기(EXP 유형)</h3>
        <p>연습 문제에서 “임의 10행”처럼 랜덤으로 뽑으라는 경우가 있다. MySQL에서는 <code>RAND()</code>로 랜덤 정렬 후 <code>LIMIT</code>을 사용한다.</p>
        <pre><code>SELECT title
FROM film
ORDER BY RAND()
LIMIT 10;</code></pre>

        <h3>개수 제한(LIMIT)</h3>
        <pre><code>SELECT title, rental_rate
FROM film
ORDER BY rental_rate DESC
LIMIT 5;</code></pre>
      </div>
    </section>

    <section id="distinct" class="section">
      <h2>DISTINCT</h2>
      <div class="card">
        <p>DISTINCT는 중복된 값을 한 번만 표시하는 기능이다.</p>
        <pre><code>SELECT DISTINCT rating
FROM film;</code></pre>
      </div>
    </section>

    <section id="aggregate" class="section">
      <h2>집계 함수</h2>
      <div class="card">
        <p>집계 함수는 여러 행을 계산하여 하나의 값으로 만드는 함수이다.</p>
        <ul class="list">
          <li>COUNT는 개수이다.</li>
          <li>SUM은 합계이다.</li>
          <li>AVG는 평균이다.</li>
          <li>MAX는 최댓값이다.</li>
          <li>MIN은 최솟값이다.</li>
        </ul>

        <h3>예시</h3>
        <pre><code>SELECT COUNT(*) AS 영화수
FROM film;</code></pre>

        <pre><code>SELECT
  AVG(rental_rate) AS 평균요금,
  MAX(rental_rate) AS 최고요금,
  MIN(rental_rate) AS 최저요금
FROM film;</code></pre>

        <pre><code>SELECT SUM(amount) AS 총결제금액
FROM payment;</code></pre>
      </div>
    </section>

    <section id="groupby-having" class="section">
      <h2>GROUP BY와 HAVING</h2>
      <div class="card">
        <h3>GROUP BY</h3>
        <p>GROUP BY는 같은 값끼리 묶는 기능이다. 묶은 뒤에 집계 함수를 사용하여 통계를 만들 수 있다.</p>
        <pre><code>SELECT rating, COUNT(*) AS 영화수
FROM film
GROUP BY rating;</code></pre>

        <h3>HAVING</h3>
        <p>HAVING은 GROUP BY로 묶은 결과에 조건을 거는 기능이다. WHERE는 묶기 전 조건이고 HAVING은 묶은 후 조건이다.</p>
        <pre><code>SELECT rating, COUNT(*) AS 영화수
FROM film
GROUP BY rating
HAVING COUNT(*) &gt;= 200;</code></pre>
      </div>
    </section>

    <section id="join" class="section">
      <h2>JOIN</h2>
      <div class="card">
        <p>JOIN은 서로 다른 테이블을 하나의 결과처럼 연결하는 방법이다. 공통된 번호(ID)를 기준으로 연결하는 것이 일반적이다.</p>

        <h3>JOIN이 필요한 이유</h3>
        <p>customer 테이블에는 고객 이름이 있고, rental 테이블에는 대여 기록이 있다. 고객 이름과 대여 날짜를 함께 보려면 두 테이블을 연결해야 한다.</p>

        <h3>INNER JOIN</h3>
        <p>INNER JOIN은 양쪽 테이블에 모두 존재하는 데이터만 조회하는 방식이다. 매칭되지 않는 데이터는 제외되는 특징이 있다.</p>
        <pre><code>SELECT c.first_name, c.last_name, r.rental_date
FROM customer c
INNER JOIN rental r
ON c.customer_id = r.customer_id;</code></pre>

        <h3>LEFT JOIN</h3>
        <p>LEFT JOIN은 왼쪽 테이블의 데이터는 모두 유지하는 방식이다. 오른쪽에 매칭되는 값이 없으면 NULL로 표시되는 특징이 있다.</p>
        <pre><code>SELECT c.customer_id, r.rental_id
FROM customer c
LEFT JOIN rental r
ON c.customer_id = r.customer_id;</code></pre>

        <h3>RIGHT JOIN</h3>
        <p>RIGHT JOIN은 오른쪽 테이블의 데이터는 모두 유지하는 방식이다. LEFT JOIN의 반대 개념이다. 실무에서는 LEFT JOIN을 더 자주 사용하는 편이다.</p>
        <pre><code>SELECT c.customer_id, r.rental_id
FROM customer c
RIGHT JOIN rental r
ON c.customer_id = r.customer_id;</code></pre>

        <h3>OUTER JOIN</h3>
        <p>OUTER JOIN은 한쪽에만 존재해도 모두 포함하는 JOIN 개념이다. MySQL은 FULL OUTER JOIN을 직접 지원하지 않으므로 LEFT JOIN과 RIGHT JOIN을 UNION으로 구현하는 방식이 일반적이다.</p>
        <pre><code>SELECT c.customer_id, r.rental_id
FROM customer c
LEFT JOIN rental r
ON c.customer_id = r.customer_id
UNION
SELECT c.customer_id, r.rental_id
FROM customer c
RIGHT JOIN rental r
ON c.customer_id = r.customer_id;</code></pre>

        <h3>JOIN + WHERE (EXP 유형)</h3>
        <p>JOIN으로 붙인 뒤 WHERE로 조건을 걸어 결과를 필터링하는 방식이다.</p>
        <pre><code>SELECT c.first_name, c.last_name, r.rental_date
FROM customer c
INNER JOIN rental r
ON c.customer_id = r.customer_id
WHERE r.rental_date &gt;= '2005-07-01';</code></pre>

        <h3>JOIN + GROUP BY + HAVING (실무형)</h3>
        <p>JOIN 후에 고객별 대여 횟수 같은 통계를 만들 수 있다. HAVING으로 통계 결과에 조건을 걸 수 있다.</p>
        <pre><code>SELECT c.customer_id, COUNT(r.rental_id) AS 대여횟수
FROM customer c
LEFT JOIN rental r
ON c.customer_id = r.customer_id
GROUP BY c.customer_id
HAVING COUNT(r.rental_id) &gt;= 10
ORDER BY 대여횟수 DESC;</code></pre>

        <h3>JOIN + 집계 + 복합 조건 (최종 종합)</h3>
        <pre><code>SELECT
  c.customer_id,
  COUNT(r.rental_id) AS 대여횟수,
  SUM(p.amount) AS 총결제금액
FROM customer c
LEFT JOIN rental r ON c.customer_id = r.customer_id
LEFT JOIN payment p ON r.rental_id = p.rental_id
GROUP BY c.customer_id
HAVING COUNT(r.rental_id) &gt;= 10
ORDER BY 총결제금액 DESC
LIMIT 10;</code></pre>
      </div>
    </section>

    <!-- =======================
         ✅ 서브쿼리(추가)
         - 첨부 PDF의 "정의/종류/연습문제" 흐름을 Sakila로 변환
         ======================= -->
    <section id="subquery" class="section">
      <h2>서브쿼리</h2>
      <div class="card">
        <h3>서브쿼리란?</h3>
        <p>서브쿼리는 SQL 문 안에 또 다른 SELECT 문을 중첩해서 사용하는 방식이다. 괄호 <code>( )</code> 안에 작성하며, 상위 쿼리에서 조건이나 값처럼 활용하는 것이 핵심이다.</p>

        <div class="note">
          <strong>기억 포인트</strong>
          <ul class="list">
            <li>서브쿼리는 <strong>괄호 ( )</strong> 안에 들어간다.</li>
            <li>서브쿼리 결과가 <strong>1행인지 여러 행인지</strong>에 따라 연산자가 달라진다.</li>
            <li>서브쿼리는 JOIN으로도 풀 수 있지만, 처음에는 “조건 만들기”로 이해하는 편이 쉽다.</li>
          </ul>
        </div>

        <h3>서브쿼리의 종류</h3>
        <p>첨부 자료에서는 단일 행/다중 행/스칼라/상관 서브쿼리로 구분한다. </p>

        <hr/>

        <h3>1) 단일 행 서브쿼리 (결과가 1행)</h3>
        <p>서브쿼리가 딱 1개의 값(1행 1열)을 반환하는 경우이다. 보통 <code>=</code>, <code>&gt;</code>, <code>&lt;</code> 같은 비교 연산자로 연결한다.</p>
        <pre><code>-- 예: 가장 비싼(대체비용이 가장 큰) 영화의 제목과 대체비용 보기
SELECT title, replacement_cost
FROM film
WHERE replacement_cost = (
  SELECT MAX(replacement_cost)
  FROM film
);</code></pre>

        <pre><code>-- 예: 평균 대여요금보다 비싼 영화만 보기
SELECT title, rental_rate
FROM film
WHERE rental_rate &gt; (
  SELECT AVG(rental_rate)
  FROM film
);</code></pre>

        <div class="note">
          <strong>주의</strong>
          <p>단일 행 서브쿼리인데 결과가 여러 행이 나오면 에러가 날 수 있다. 이때는 IN/ANY/ALL 같은 다중 행 방식으로 바꿔야 한다.</p>
        </div>

        <hr/>

        <h3>2) 다중 행 서브쿼리 (결과가 여러 행)</h3>
        <p>서브쿼리 결과가 여러 행이면 <code>IN</code>, <code>ANY</code>, <code>ALL</code> 같은 연산자를 사용한다. (첨부 자료에서 IN/ANY/ALL 언급) </p>

        <h4>2-1) IN</h4>
        <pre><code>-- 예: 'Comedy' 또는 'Action' 장르 영화 제목 보기 (IN + 서브쿼리)
SELECT f.title
FROM film f
WHERE f.film_id IN (
  SELECT fc.film_id
  FROM film_category fc
  WHERE fc.category_id IN (
    SELECT c.category_id
    FROM category c
    WHERE c.name IN ('Comedy', 'Action')
  )
);</code></pre>

        <h4>2-2) ANY / ALL</h4>
        <p>ANY는 “여러 값 중 하나라도 만족”이고, ALL은 “모든 값을 만족”이다.</p>
        <pre><code>-- 예: 'Comedy' 장르 영화들의 대여요금(rental_rate) 중
-- 어떤 값(ANY)보다 큰 대여요금인 영화 찾기
SELECT title, rental_rate
FROM film
WHERE rental_rate &gt; ANY (
  SELECT f2.rental_rate
  FROM film f2
  WHERE f2.film_id IN (
    SELECT fc.film_id
    FROM film_category fc
    WHERE fc.category_id = (
      SELECT category_id FROM category WHERE name = 'Comedy'
    )
  )
);</code></pre>

        <pre><code>-- 예: 'Comedy' 장르 영화들의 대여요금(rental_rate)보다
-- 모두(ALL) 큰 대여요금인 영화 찾기
SELECT title, rental_rate
FROM film
WHERE rental_rate &gt; ALL (
  SELECT f2.rental_rate
  FROM film f2
  WHERE f2.film_id IN (
    SELECT fc.film_id
    FROM film_category fc
    WHERE fc.category_id = (
      SELECT category_id FROM category WHERE name = 'Comedy'
    )
  )
);</code></pre>

        <hr/>

        <h3>3) 스칼라 서브쿼리 (SELECT 절에서 값처럼 사용)</h3>
        <p>스칼라 서브쿼리는 SELECT 절에서 “한 칸짜리 값”처럼 붙여서 보여주는 방식이다. 첨부 자료의 “학생 이름 + 학과 이름 같이 조회” 형태와 같다. </p>
        <pre><code>-- 예: 각 고객의 총 결제 금액을 고객 이름 옆에 같이 표시하기 (스칼라 서브쿼리)
SELECT
  c.customer_id,
  c.first_name,
  c.last_name,
  (
    SELECT SUM(p.amount)
    FROM payment p
    WHERE p.customer_id = c.customer_id
  ) AS total_payment
FROM customer c
ORDER BY total_payment DESC;</code></pre>

        <div class="note">
          <strong>팁</strong>
          <p>스칼라 서브쿼리는 행마다 한 번씩 계산될 수 있어 느려질 수 있다. 데이터가 커지면 JOIN + GROUP BY로 바꾸는 연습도 필요하다.</p>
        </div>

        <hr/>

        <h3>4) 상관 서브쿼리 (외부 쿼리의 각 행과 연결되어 실행)</h3>
        <p>상관 서브쿼리는 서브쿼리가 바깥 쿼리의 값을 참조한다. 첨부 자료의 “자기 학과 평균보다 키 큰 학생”과 같은 구조이다. </p>

        <pre><code>-- 예: 고객별 평균 결제금액보다 큰 결제(payment)만 찾기 (상관 서브쿼리)
SELECT
  p.payment_id,
  p.customer_id,
  p.amount
FROM payment p
WHERE p.amount &gt; (
  SELECT AVG(p2.amount)
  FROM payment p2
  WHERE p2.customer_id = p.customer_id
)
ORDER BY p.customer_id, p.amount DESC;</code></pre>

        <hr/>

        <h3>5) EXISTS / NOT EXISTS (있다/없다 체크)</h3>
        <p>EXISTS는 “서브쿼리 결과가 한 행이라도 존재하면 참”이다. NOT EXISTS는 반대이다. “수강생이 한 명도 없는 과목” 같은 문제에서 특히 유용하다.</p>

        <pre><code>-- 예: 대여 기록이 한 번도 없는 고객 찾기 (NOT EXISTS)
SELECT c.customer_id, c.first_name, c.last_name
FROM customer c
WHERE NOT EXISTS (
  SELECT 1
  FROM rental r
  WHERE r.customer_id = c.customer_id
);</code></pre>

        <pre><code>-- 예: 결제가 존재하는 고객만 찾기 (EXISTS)
SELECT c.customer_id, c.first_name, c.last_name
FROM customer c
WHERE EXISTS (
  SELECT 1
  FROM payment p
  WHERE p.customer_id = c.customer_id
);</code></pre>

<section>
        <hr/>


    <section id="execution-order" class="section">
      <h2>SELECT 실행 순서</h2>
      <div class="card">
        <p>SELECT 문은 작성 순서와 다르게 실행되는 특징이 있다. 아래 순서를 이해하면 SQL이 훨씬 쉬워지는 효과가 있다.</p>
        <ol class="list">
          <li>FROM</li>
          <li>JOIN</li>
          <li>WHERE</li>
          <li>GROUP BY</li>
          <li>HAVING</li>
          <li>SELECT</li>
          <li>ORDER BY</li>
          <li>LIMIT</li>
        </ol>

        <div class="note">
          <p><strong>중요한 이유</strong>는 WHERE는 그룹화 이전에 적용되고, HAVING은 그룹화 이후에 적용되기 때문이다.</p>
        </div>
      </div>
    </section>

    <section id="summary" class="section">
      <h2>정리</h2>
      <div class="card">
        <ul class="list">
          <li>SELECT는 조회 명령어이다.</li>
          <li>WHERE는 조건 필터이다.</li>
          <li>ORDER BY는 정렬이다.</li>
          <li>LIMIT는 개수 제한이다.</li>
          <li>DISTINCT는 중복 제거이다.</li>
          <li>집계 함수는 통계를 만드는 기능이다.</li>
          <li>GROUP BY는 묶기이다.</li>
          <li>HAVING은 묶은 후 조건이다.</li>
          <li>JOIN은 테이블 연결이다.</li>
          <li>서브쿼리는 SQL 안의 SELECT이다.</li>
          <li>단일 행/다중 행/스칼라/상관/EXISTS 방식으로 나뉜다.</li>
        </ul>
        <p class="foot">이 강의안은 서브쿼리까지 포함하여 실습 문제를 바로 풀 수 있도록 구성되어 있다.</p>
      </div>
    </section>

  </main>

  <footer class="footer">
    <div class="container">
      <p>© MySQL SELECT Lecture (Sakila). 모든 예제는 학습 목적의 샘플이다.</p>
    </div>
  </footer>
</body>
</html>
